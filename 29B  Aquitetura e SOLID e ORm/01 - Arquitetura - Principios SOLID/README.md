O que vamopa Aprender?
Hoje vamos come√ßar a aprender sobre os cincos principios que abragem o SOLID
Esses Principios, ou boas praticas, ditam como seu codigo deve ser escrito e como ele deve ser organizado para otimizar manuten√ß√£o, legibilidade e testabilidade

S  = singou responsabi principo
O  = open/close  principo
L  =
I  =
D  = Dependice inversible principo

## Orienta√ß√£o a Objeto

Voc√™ ser√° capaz de:
Escrever fun√ß√µes que tenham uma √∫nica responsabilidade no escopo da sua aplica√ß√£o.
Escrever classes com fun√ß√µes que est√£o abertas para extens√£o e fechadas para modifica√ß√£o.
Injetar depend√™ncias para dar a quem chama o controle sobre como uma fun√ß√£o faz o que precisa.

## Por que isso √© importante?

Falar de Solid significa falar de qualidade de codigo. Desde o come√ßo do curso  voce v√™ que, na Trybe, refor√ßamos muito

Por que isso √© importante?
Falar de SOLID significa falar de qualidade de c√≥digo . Desde o come√ßo do curso voc√™ v√™ que, na Trybe, refor√ßamos muito a necessidade de se escrever um bom c√≥digo. Desde o come√ßo o ESLint est√° a√≠ para ajudar nisso. A arquitetura SOLID √© vastamente usada pelo mundo para criar aplica√ß√µes de software f√°ceis de se manter e alterar ao longo do tempo. Embora parte dos princ√≠pios seja voltada especificamente para Programa√ß√£o Orientada a Objeto (POO)__, que nem sempre praticamos em JavaScript, parte do que eles prop√µem √© aplic√°vel em qualquer cen√°rio! Sabe quando voc√™ l√™ um c√≥digo _bonito ? Um c√≥digo simples, que faz o que precisa, aquele de bater o olho e entender tudo? Muitas vezes nos vem o pensamento de que "eu nunca conseguiria bolar um c√≥digo assim". Isso √© exatamente o que as li√ß√µes do SOLID nos ajudam a conseguir!
Criar e manter um c√≥digo de excel√™ncia durante todo o processo de desenvolvimento de um produto √© o principal objetivo de um desenvolvedor de software que preza pela qualidade no longo prazo . Ao aplicar um bom padr√£o de design no seu c√≥digo, voc√™:
Facilita a manuten√ß√£o do c√≥digo;
Facilita a escrita de testes;
Melhora a legibilidade e a navega√ß√£o;
Evita trechos de c√≥digo muito complexos ou duplicados.
Escrever c√≥digo complexo √© uma tarefa simples, mas escrever c√≥digo simples √© uma tarefa muito complexa. Manter o c√≥digo simples e limpo, requer muita pr√°tica. Como Sandy Metz diz, aplica√ß√µes bem-sucedidas evoluem e mudam com o tempo sempre. Sem seguir bons princ√≠pios, seu c√≥digo fica uma bagun√ßa e fica imposs√≠vel "encostar nele" sem alguma coisa parar de funcionar. A arquitetura SOLID existe para que as partes do seu c√≥digo sejam t√£o independentes umas das outras quanto poss√≠vel, para facilitar sua evolu√ß√£o no futuro.
Em outras palavras: qualidade de c√≥digo √© mais do que respeitar o ESLint ! Vamos come√ßar a ver isso aqui e agora! üöÄ

# O que exatamente √© SOLID?
A palavra solid (s√≥lido) no contexto de programa√ß√£o, √© um acr√¥nimo para cinco princ√≠pios e que de fato, se aplicados de maneira conjunta e inteligente, geram solidez e durabilidade para sua arquitetura como um todo. Ele √© mais focado em programa√ß√£o orientada a objetos (POO) , mas tamb√©m √© aplic√°vel em outros cen√°rios similares. √â importante ressaltar, no entanto, que o conceito de SOLID ao p√© da letra √© bem complicado de ser entendido. Se definirmos todos os princ√≠pios como propostos no artigo cient√≠fico escrito por Robert C. Martin, nos arriscamos a criar mais confus√£o do que qualquer coisa. Portanto, ensinaremos aqui uma vers√£o de SOLID mais adequada √† nossa realidade. Posteriormente no curso, no m√≥dulo de Ci√™ncia da Computa√ß√£o, vamos estudar SOLID novamente com mais detalhes, ent√£o n√£o se preocupe! Dito isso, nas defini√ß√µes originais, SOLID significa o seguinte (se prepare para ter d√∫vidas):
S ingle responsibility principle ( Princ√≠pio da responsabilidade √∫nica ): uma classe deve ter apenas uma √∫nica responsabilidade;
O pen/Closed principle ( Princ√≠pio aberto/fechado ): entidades de software devem ser abertas para extens√£o, mas fechadas para modifica√ß√£o;
L iskov substitution principle ( Princ√≠pio de substitui√ß√£o de Liskov ): objetos em um programa devem ser substitu√≠veis por inst√¢ncias de seus subtipos, sem alterar a funcionalidade do programa;
I nterface segregation principle ( Princ√≠pio da segrega√ß√£o da interface ): muitas interfaces de clientes espec√≠ficas s√£o melhores do que uma para todos os prop√≥sitos;
D ependency inversion principle ( Princ√≠pio da invers√£o da depend√™ncia ): deve-se depender de abstra√ß√µes, n√£o de objetos concretos.
Primeiramente, √© importante esclarecer que os princ√≠pios L e I n√£o ser√£o abordados hoje! Eles funcionam melhor quando aplicados √† orienta√ß√£o por objeto, ent√£o falaremos mais deles futuramente, no m√≥dulo de Ci√™ncia da Computa√ß√£o. Os demais nos s√£o √∫teis mesmo em JavaScript! Primeiramente, vamos traduzir as defini√ß√µes deles para portugu√™s leg√≠vel:
S ingle responsibility principle ( Princ√≠pio da responsabilidade √∫nica ): uma classe ou fun√ß√£o deve ter uma, e apenas uma, tarefa a realizar dentro do seu c√≥digo;
O pen/Closed principle ( Princ√≠pio aberto/fechado ): voc√™ deve ser capaz de estender um comportamento de uma fun√ß√£o sem modificar seus comportamentos j√° existentes;
L iskov substitution principle ( Princ√≠pio de substitui√ß√£o de Liskov ): N√£o se aplica. Estudaremos este depois!
I nterface segregation principle ( Princ√≠pio da segrega√ß√£o da interface ): N√£o se aplica. Estudaremos este depois!
D ependency inversion principle ( Princ√≠pio da invers√£o da depend√™ncia ): quem usa uma fun√ß√£o deve ser capaz de determinar quais outros m√≥dulos ela usa em sua l√≥gica.
Uma palavra bastante importante e que deve ser ressaltada √© a "Princ√≠pio" . Isso quer dizer que nada do que est√° aqui pode ser taxado de sempre bom ou sempre ruim , mas sim como recomendado ou n√£o recomendado . Ou seja, s√£o boas pr√°ticas. Existem situa√ß√µes em que pode fazer sentido ignorar um desses princ√≠pios. Por isso, n√£o seja radical. Sempre reflita sobre o porqu√™ de estar usando/fazendo algo. Nunca se esque√ßa: ao escrever um c√≥digo, o objetivo √© torn√°-lo f√°cil de ser entendido e f√°cil de ser mantido . Regra nenhuma, princ√≠pio nenhum e caso especial nenhum deve piorar a legibilidade do seu c√≥digo.
Dito isso, princ√≠pios como o SOLID e regras como as do ESLint geralmente v√™m para o bem. Escrever c√≥digo realmente bom √© dif√≠cil! Seguir as regras, e confiar nelas, nos coloca num caminho que, quando conclu√≠do, vai nos dar um bom c√≥digo! O objetivo da aula de hoje √© entender como isso acontece e por qu√™.
N√£o se preocupe se n√£o tiver entendido os princ√≠pios ainda. A seguir vamos nos aprofundar com mais detalhes em cada um deles.

# Single responsibility principle

H√° uma regra do ESLint (Provida pelo plugin sonarjs ) que certamente j√° te assombrou no passado: a regra de Complexidade Cognitiva ( sonarjs/cognitive-complexity ) . Em poucas palavras, essa regra, como outras em conjunto ( Complexidade Ciclom√°tica , N√∫mero m√°ximo de linhas por fun√ß√£o N√∫mero m√°ximo de caracteres por linha , entre outros) garante que nenhuma de suas fun√ß√µes √© complicada demais. Se ela √© muito grande e/ou muito confusa, a regra te alerta para que deixe seu c√≥digo menor e mais simples.
Mas muitas vezes isso √© meio desafiador, certo? "Como raios eu deixo essa fun√ß√£o do tamanho que se pede?!". Uma forma de se orientar a fazer isso √© justamente o princ√≠pio da responsabilidade √∫nica .

// ./tests/unit/getLetterGrades.test.js

const { expect } = require('chai');

const { getLetterGrades } = require('../../index');

const disciplinesDict = {
  mathematics: 'matem√°tica',
};

describe('Testando a fun√ß√£o "getLetterGrades"', function () {
  describe('quando a nota √© maior ou igual a 0.9', function () {
    it('retorna "A"', function () {
      const discipline = { name: disciplinesDict.mathematics, grade: 0.9 };

      const {
        letterGrade,
      } = getLetterGrades(discipline);

      expect(letterGrade).to.be.equals('A');
    });
  });

  describe('quando a nota √© maior ou igual a 0.8 e menor que 0.9', function () {
    it('retorna "B"', function () {
      const discipline = { name: disciplinesDict.mathematics, grade: 0.8 };

      const {
        letterGrade,
      } = getLetterGrades(discipline);

      expect(letterGrade).to.be.equals('B');
    });
  });

  describe('quando a nota √© maior ou igual a 0.7 e menor que 0.8', function () {
    it('retorna "C"', function () {
      const discipline = { name: disciplinesDict.mathematics, grade: 0.7 };

      const {
        letterGrade,
      } = getLetterGrades(discipline);

      expect(letterGrade).to.be.equals('C');
    });
  });

  describe('quando a nota √© maior ou igual a 0.6 e menor que 0.7', function () {
    it('retorna "D"', function () {
      const discipline = { name: disciplinesDict.mathematics, grade: 0.6 };

      const {
        letterGrade,
      } = getLetterGrades(discipline);

      expect(letterGrade).to.be.equals('D');
    });
  });

  describe('quando a nota √© maior ou igual a 0.1 e menor que 0.6', function () {
    it('retorna "E"', function () {
      const discipline = { name: disciplinesDict.mathematics, grade: 0.1 };

      const {
        letterGrade,
      } = getLetterGrades(discipline);

      expect(letterGrade).to.be.equals('E');
    });
  });

  describe('quando a nota √© menor que 0.1', function () {
    it('retorna "F"', function () {
      const discipline = { name: disciplinesDict.mathematics, grade: 0.05 };

      const {
        letterGrade,
      } = getLetterGrades(discipline);

      expect(letterGrade).to.be.equals('F');
    });
  });
});

## Open/close principle
Imagine, para o nosso exemplo, o seguinte cen√°rio: somos uma empresa que administra notas de escolas. Cada escola tem seu corte aprova√ß√£o ( no nosso caso, 0,7). Otimo Fizemos nosso produto, ele funcionou,e agora uma segunda escola quer ser nossa cliente! Mas o corte de aprova√ß√£o dela √© 0,8. Precisamos que nosso sistema contemple essa nova realidade A√≠ fazemos assim:

// ./index.js

// ...

/* "Converter" */
const percentageGradesIntoLetters = ({ name, disciplines, school }) => ({
  name,
  disciplines: disciplines.map(getLetterGrades),
  school});

/* "Determinar" */
const approvedStudents = ({ school, disciplines }) =>
  disciplines.every(({ grade }) =>
    (school === 'Standard' ? grade >= 0.7 : grade >= 0.8));

/* "Atualizar" */
const updateApprovalData = ({ name: studentName, disciplines }) => {
  console.log(`A pessoa com nome ${studentName} foi aprovada!`);

  disciplines.map(({ name, letterGrade }) =>
    console.log(`${name}: ${letterGrade}`));
};

// ...

/* Abaixo temos o exemplo de execu√ß√£o com algumas adi√ß√µes */
const students = [
  {
    name: 'Lee',
    school: 'Standard',
    disciplines: [
      { name: 'matem√°tica', grade: 0.8 },
      { name: 'hist√≥ria', grade: 0.9 },
    ],
  },
  {
    name: 'Albus',
    school: 'Hogwarts',
    disciplines: [
      { name: 'divination', grade: 0.8 },
      { name: 'potions', grade: 0.9 },
    ],
  },
];

// setApproved(students);

Essa Solu√ß√£o funciona, mas n√£o esta boa! N√≥s tivemos que mudar nossa fun√ß√£o para acrescentar o novo comportamento a ela! O que acontecer√° quando surgi uma terceira escola? Talvez uma quarta, quinta e assim por diante.

Pois bem! Comforma estabelecemos no inicio, o que esse principio nos diz √© o seguinte:
  Voc√™ deve ser capaz de entender um compoirtamento de uma fun√ß√£o sem modificar seus comportamentos ja existentes.

Beleza, mas o que isso significa? Significa que, caso voc√™ precise acrescentar um comportamento ao seu c√≥digo e isso n√£o for possivel sem mudar trechos de codigos que ja existam, temos um problema. veja bem: quando um codigo funciona e esta em produ√ß√£o numa aplica√ß√£o enorme, queremos evitar mudaro que ja existe e funciona.

Mas todo c√≥digo precisa ser atualizado com o tempo. Cmomo podemos , ent√£o atualizar o nosso codigo sem alterar o que ja existe ? O que se deve ser buscar fazer  √© escrever o √ßodigo de modo que, no futuro, voc√™ , voc√™ poissa  acrescentar comportamento sem mudar os que ja existem.

No nosso caso, seria ser capaz de aobter o corte de aprova√ß√£o os nomes conceitos de quaisquer escolas sem alterar a l√≥gica da nossa aplica√ß√£o! isso requer que refatoremos o nosso c√≥digo para deixa-lo aberto para extens√µes, mamtendo-o fechado para modifica√ß√µes

// ./index.js

/* Apoio para a fun√ß√£o `setApproved` */
const SCHOOL_DATA = {
  Standard: {
    approvalGrade: 0.7
  },
  Hogwarts: {
    approvalGrade: 0.8
  }
};

// ...

/* "Determinar" */
const approvedStudents = (disciplines, { approvalGrade }) =>
  disciplines.every(({ grade }) => grade > approvalGrade);

// ...

function setApproved(students) {
  students
    .map(percentageGradesIntoLetters)
    .filter(({ disciplines, school }) => approvedStudents(disciplines, SCHOOL_DATA[school]))
    .map(updateApprovalData);
}


Observe que, agora, a nossa fun√ß√£o approvedStudents est√° totalmente gen√©rica . Quando quisermos acrescentar mais uma escola, ou duas, ou cem, basta adicionar os dados dela √† nossa "base". Aqui, simulamos com o objeto SCHOOL_DATA , assim como o fizemos com o objeto GRADE_DICT , onde tamb√©m est√°vamos com um problema com o "engessamento" da fun√ß√£o getGradeLetter . Conseguiremos, assim, estender o nosso comportamento sem modificar a fun√ß√£o mais. Agora ela respeita o Open/Closed !
Nossos testes tamb√©m ficar√£o muito mais leg√≠veis e gen√©ricos quanto ao crit√©rio de aprova√ß√£o:

// ./tests/unit/approvedStudents.test.js

const { expect } = require('chai');

const { approvedStudents } = require('../../index');

const disciplinesDict = {
  mathematics: 'matem√°tica',
  history: 'hist√≥ria',
};

describe('Testando a fun√ß√£o "approvedStudents"', function () {
  const APPROVAL_GRADE = { approvalGrade: 0.7 };

  describe('quando todas as notas s√£o maiores que o crit√©rio de aprova√ß√£o', function () {
    it('retorna "true"', function () {
      const disciplines = [
        { name: disciplinesDict.mathematics, grade: 0.8 },
        { name: disciplinesDict.history, grade: 0.9 },
      ];

      const result = approvedStudents(disciplines, APPROVAL_GRADE);

      expect(result).to.be.equal(true);
    });
  });

  describe('quando todas as notas s√£o menores que o crit√©rio de aprova√ß√£o', function () {
    it('retorna "false"', function () {
      const disciplines = [
        { name: disciplinesDict.mathematics, grade: 0.1 },
        { name: disciplinesDict.history, grade: 0.2 },
      ];

      const result = approvedStudents(disciplines, APPROVAL_GRADE);

      expect(result).to.be.equal(false);
    });
  });

  describe('quando parte das notas s√£o menores que o crit√©rio de aprova√ß√£o', function () {
    it('retorna "false"', function () {
      const disciplines = [
        { name: disciplinesDict.mathematics, grade: 0.5 },
        { name: disciplinesDict.history, grade: 0.9 },
      ];

      const result = approvedStudents(disciplines, APPROVAL_GRADE);

      expect(result).to.be.equal(false);
    });
  });
});

Dessa forma, no momento em que voc√™ est√° escrevendo uma fun√ß√£o para resolver um problema, √© importante se perguntar se √© poss√≠vel que, futuramente, essa fun√ß√£o seja usada para resolver outros problemas similares ao atual. Se sim, se esforce para deix√°-la aberta a extens√µes para poder mant√™-la fechada a modifica√ß√µes . Como em qualquer princ√≠pio, n√£o h√° necessidade de radicalismo aqui: se uma fun√ß√£o n√£o deve ser usada em outros contextos, ela n√£o precisa estar aberta a extens√£o. Se no futuro isso mudar, voc√™ faz uma refatora√ß√£o. Mas pense com cuidado! A fun√ß√£o deixada aberta hoje √© uma refatora√ß√£o a menos para amanh√£!

# Dependency Inversion Principle

Aqui n√£o necessitaremos de nenhum arquivo das se√ß√µes anteriores.

Para este exemplo iremos usar novas depend√™ncias, execute o seguinte comando para adicionar os pacotes:npm
## install node-fetch@2.6.5 axios

Suponha que voc√™ quer escrever um programa em JavaScript que faz uma requisi√ß√£o para a API de dad jokes . Assim sendo, voc√™ escreve o seguinte c√≥digo:

Copiar
// ./dipExample.js

const fetch = require('node-fetch');

const url = 'https://icanhazdadjoke.com';

const requestWithFetch = () => {
  fetch(url, {
    headers: new fetch.Headers({
      Accept: 'application/json',
    }),
  })
    .then((response) => response.json())
    .then((data) => console.log(data.joke))
    .catch((err) => console.log(err));
};

const getJokes = (numberOfJokes) => {
  for (let i = 0; i < numberOfJokes; i += 1) requestWithFetch();
};

getJokes(5);

module.exports = { getJokes };
Problema resolvido! Mas agora vamos pensar na quest√£o que est√° nos acompanhando por todo o dia de hoje: como podemos reusar esse c√≥digo no futuro para outros contextos sem alterar o c√≥digo que j√° existe? Olhe para esse nosso exemplo: a√≠, estamos usando o fetch para fazer uma requisi√ß√£o √† API. A fun√ß√£o depende do fetch para funcionar. O fetch , portanto, √© uma depend√™ncia da fun√ß√£o! E o que seria, ent√£o, a invers√£o de depend√™ncia? Conforme foi dito l√° em cima
Quem usa uma fun√ß√£o deve ser capaz de determinar quais outros m√≥dulos ela usa em sua l√≥gica.
Em outras palavras, "quem usa decide como se usa". Como assim? Imagine que, no futuro, decide-se abolir o uso de fetch no seu projeto em favor do axios . N√£o queremos alterar o nosso c√≥digo antigo (vai que ele quebra üò¨), mas c√≥digo novo deve vir com a API nova.
S√≥ que n√≥s queremos usar a nossa fun√ß√£o getJokes numa funcionalidade nova que estamos fazendo, mas sem utilizar o fetch ! Como fazemos? Assim:
Copiar
// ./dipExample.js

const axios = require('axios').default;
const fetch = require('node-fetch');

const url = 'https://icanhazdadjoke.com';

const requestWithAxios = () => {
  axios
    .get(url, {
      headers: { Accept: 'text/plain' },
    })
    .then((response) => console.log(response.data));
};

// const requestWithFetch = () => {
// ...

const getJokes = (numberOfJokes, jokeRequester = requestWithFetch) => {
  for (let i = 0; i < numberOfJokes; i += 1) jokeRequester();
};

getJokes(5, requestWithAxios);

module.exports = { getJokes };
Repare que, agora, quem chama a fun√ß√£o decide qual depend√™ncia a fun√ß√£o ter√° , seja o Axios ou o Fetch. E ao colocarmos a requestWithFetch como valor padr√£o para o par√¢metro que acrescentamos √† fun√ß√£o, garantimos que, em todos os lugares onde essa fun√ß√£o j√° era usada, tudo continuar√° funcionando.
Isso que fizemos foi a chamada invers√£o de depend√™ncia . Quem usa decide qual depend√™ncia a fun√ß√£o ter√°.
Mais uma vez olhando pela perspectiva de testes, conseguimos perceber uma grande melhoria na testabilidade aplicando invers√£o de depend√™ncia . Podemos escrever testes para a fun√ß√£o da seguinte maneira:
Copiar
// ./tests/unit/getJokes.test.js

const { stub } = require('sinon');
const { expect } = require('chai');

const { getJokes } = require('../../dipExample');

const requesterStub = stub();

describe('Testando a fun√ß√£o "getJokes"', function () {
  it('"requester stub" √© chamado uma vez', function () {
    getJokes(1, requesterStub);

    expect(requesterStub.calledOnce).to.be.equals(true);
  });
});
Rode com NAME=getJokes npm test para validar seu teste.
Perceba que como a fun√ß√£o respons√°vel por realizar a chamada √© passada via par√¢metro, podemos facilmente criar um stub e pass√°-lo. Sem a invers√£o, ter√≠amos que criar um stub de acordo com a implementa√ß√£o do jokeRequester , tendo que entender a l√≥gica do c√≥digo para encontrar qual a fun√ß√£o seria utilizada (a com axios ou com fetch ) e ent√£o interceptar tal chamada para conseguir fazer o stub .
Al√©m disso, se for adicionado um novo jokeRequester ou alterado qual deles seria chamado, nosso teste n√£o precisar√° ser alterado.
Outro ponto √© que conseguimos testar de maneira unit√°ria cada implementa√ß√£o de jokeRequester , com fetch , com axios ou qualquer outra implementa√ß√£o. No nosso exemplo tais implementa√ß√µes s√£o chamadas simples de API, mas √© muito comum situa√ß√µes em que tais depend√™ncias possuem diversas l√≥gicas internas e comportamentos, onde esse princ√≠pio ajudar√° muito.
Agora veremos na pr√°tica como funcionam os 3 princ√≠pios que vimos at√© o momento.

## Conclus√£o
hoje N√≥s come√ßamos a entender tr√™s dos cincos principios de qualidade de codigos do SOLID: o principio da responsabilidade √πnica, o princio aberto fechado e o principio da invers√£o de responsabilidade de depend√™ncia. √à muito importante ficar claro: esses principios S√£o complexos no seu entendimento e na sua aplica√ß√£o, e n√≥s hoje ≈õo come√ßamos a arranhar as possibilidades que eles nos t√™m a oferecer!

No modulo de Ci√™ncias da Computa√ß√£o, no contexto de programa√ß√£o Orientada a Objeto, estudaremos o SOLID com mais profundidade. Por Hora tenha esse entendimento parcial em mente e busque sempre recorrer aos principios quando escrever c√≥digos. Acione-os, pergunte-se o seu codigo o segue. Acredite nos principios e implemente-os passo a passo. no final, voc√™ tera feito a dificil tarefa de escrever um c√≥digo simples de ser entender e se estender.